<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Fundamentals of Computer Systems | mushetty.me</title>
<meta name="keywords" content="">
<meta name="description" content="Compilation of notes for Fundamentals of Computer Systems class for Spring 2023.
 Administrative Stuff  Exams Grades   Lecture 0 Lecture 1  CPU Models Addition in different bases Definitions Modular Arithmetic Integer format with word size restriction  Unsigned binary numbers:  Binary Addition Algorithm (BAA)   Negative numbers  Signed Magnitude Representation 1&rsquo;s Complement Problems with Signed Magnitude and 1&rsquo;s Complement 2&rsquo;s complement Intuition behind 2&rsquo;s complement       Lecture 2  Why 2&rsquo;s complement?">
<meta name="author" content="">
<link rel="canonical" href="https://mushetty.me/notes/fundies/fundies/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a5456a2fb6485e28d3190c101c9f7fea21d7eddeb7cf1b8dddf20aeb314df0cf.css" integrity="sha256-pUVqL7ZIXijTGQwQHJ9/6iHX7d63zxuN3fIK6zFN8M8=" rel="preload stylesheet" as="style">
<link rel="stylesheet" href="" />
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://mushetty.me/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mushetty.me/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mushetty.me/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mushetty.me/apple-touch-icon.png">
<link rel="mask-icon" href="https://mushetty.me/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>


<meta property="og:title" content="Fundamentals of Computer Systems" />
<meta property="og:description" content="Compilation of notes for Fundamentals of Computer Systems class for Spring 2023.
 Administrative Stuff  Exams Grades   Lecture 0 Lecture 1  CPU Models Addition in different bases Definitions Modular Arithmetic Integer format with word size restriction  Unsigned binary numbers:  Binary Addition Algorithm (BAA)   Negative numbers  Signed Magnitude Representation 1&rsquo;s Complement Problems with Signed Magnitude and 1&rsquo;s Complement 2&rsquo;s complement Intuition behind 2&rsquo;s complement       Lecture 2  Why 2&rsquo;s complement?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mushetty.me/notes/fundies/fundies/" /><meta property="article:section" content="notes" />
<meta property="article:published_time" content="2023-01-17T22:19:34-05:00" />
<meta property="article:modified_time" content="2023-02-13T13:51:49-05:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Fundamentals of Computer Systems"/>
<meta name="twitter:description" content="Compilation of notes for Fundamentals of Computer Systems class for Spring 2023.
 Administrative Stuff  Exams Grades   Lecture 0 Lecture 1  CPU Models Addition in different bases Definitions Modular Arithmetic Integer format with word size restriction  Unsigned binary numbers:  Binary Addition Algorithm (BAA)   Negative numbers  Signed Magnitude Representation 1&rsquo;s Complement Problems with Signed Magnitude and 1&rsquo;s Complement 2&rsquo;s complement Intuition behind 2&rsquo;s complement       Lecture 2  Why 2&rsquo;s complement?"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Fundamentals of Computer Systems",
      "item": "https://mushetty.me/notes/fundies/fundies/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Fundamentals of Computer Systems",
  "name": "Fundamentals of Computer Systems",
  "description": "Compilation of notes for Fundamentals of Computer Systems class for Spring 2023.\n Administrative Stuff  Exams Grades   Lecture 0 Lecture 1  CPU Models Addition in different bases Definitions Modular Arithmetic Integer format with word size restriction  Unsigned binary numbers:  Binary Addition Algorithm (BAA)   Negative numbers  Signed Magnitude Representation 1\u0026rsquo;s Complement Problems with Signed Magnitude and 1\u0026rsquo;s Complement 2\u0026rsquo;s complement Intuition behind 2\u0026rsquo;s complement       Lecture 2  Why 2\u0026rsquo;s complement?",
  "keywords": [
    
  ],
  "articleBody": "Compilation of notes for Fundamentals of Computer Systems class for Spring 2023.\n Administrative Stuff  Exams Grades   Lecture 0 Lecture 1  CPU Models Addition in different bases Definitions Modular Arithmetic Integer format with word size restriction  Unsigned binary numbers:  Binary Addition Algorithm (BAA)   Negative numbers  Signed Magnitude Representation 1’s Complement Problems with Signed Magnitude and 1’s Complement 2’s complement Intuition behind 2’s complement       Lecture 2  Why 2’s complement?  Easy subtraction Detecting Overflow   Floating Points  IEEE standard for a 32 bit word Doubles Underflow   Boolean Algebra  Boolean Algebra Identities  Distributive Law Proof DeMorgan’s Theorem Consensus Theorem circuit Representation of Boolean Algebra  Coverting Circuits to Booleans   NAND and NOR   XOR   Duals   Lecture 3  Sum of Products (SoP) Product of Sums (PoS)  Convert SoP to PoS   Minterms Maxterms Karnaugh Map  K-map Notation Summary of Simplification with k-maps 2-bit multiplier Don’t Care Conditions   Drawing Circuits   Lecture 4  Standard Circuits  Enabler Decoder Circuit Decoder With Enable MUX (Multiplexer)  Representing Functions with Decoders and MUXes MUX trick   Shifter Circuit  Barrel Shift left w/ Wraparound L-R Shift Circuit with Rollout   Unsigned Adder Circuit  Half-Adder Full-Adder   Signed Adder/Subtractor (2’s-C)  Ripple Carry Adder Optimizing Ripple Carry (Carry Lookahead)   Merge with known 0’s Code Converter Contraction  Example 1       Lecture 5  Latch Intuition SR Latch SR Latch with Control D Latch with control     Administrative Stuff Exams  Midterm: On March 8th, 6-9 pm (tentative)  Check for conflicts   End-of-term exam: Either April 27, evening (6-9 pm) or May 5 in the evening Fill in exam conflicts (by 1/24)  Acceptable excuses: conflicting classes and religious conflicts   Fill in P-credit office hours (By 1/21)  Go to web form The top row indicates the start time of the office hours (e.g. 12 means 12-1. 12:30 means 12:30-1) Need at least 10 hours selected   Email for help: 3827-staff[at]googlegroups.com  Include 3827 in subject header. Otherwise, it will get overlooked   Use EdStem for class updates instead of Courseworks, as well as to ask questions b/c it will be faster than email  Grades  TL;DR Do Homework, go to office hours, don’t bomb the midterm or final  Lecture 0  Work on HW0 (Not graded) Why should I care about this course?  Shows how computers run “under the hood” Learn “parallel thinking”  Humans think sequentially Circuits run multiple “threads” at once   Useful to understand these ideas in many domains  Systems Programming Languages (Compilers and Interpreters) Quantum Computing ML/AI      Lecture 1 CPU Models  CPU: “brain” of the computer  Control Unit: D oes calculations on data in datapath   Memory: Stores data (for later use) I/O: Interface to the outside (disk, network, monitor, keyboard, mouse, etc.) Simpler model of CPU:  Discrete inputs (over time) Discrete Information Processing System  communicates with System state and output something based on input   System State  Remembers previous information      Addition in different bases  humans: 10 digits: {0,1,2,3,4,5,6,7,8,9}  $(4537.8)_{10} = 4*10^{3}+5*10^{2}+3*10{1}+7*10^{0}+8*10^{-1}$ Shifting everything to the left is multiplication by 10   computers: 2 digits: {0,1}  $(1011.1)_{2} = 1*2^{3}+0*2^{2}+1*2^{1}+1*2^{0}+1*2^{-1} = 11.5$ Shifting everything to the left multiplies by 2   Hex: 16 digits {0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F}  Hex numbers specified as 0x26BA $0x26BA = 2*16^{3}+6*16^{2}+11*16^{1}+10*16^{0} = (9914)_{10}$ We use hex since it is more human readable and is easy to convert to and from binary  a base-2 4 digit can be multiplied by 16 by shifting 4 to the left ($1100 \\rightarrow 1100\\ 0000$) a base-16 1 digit can be multiplied by 16 by shifting 1 to the left ($0xD \\rightarrow 0xD0$) To convert binary to hex, break hex into groups of 4 and convert each group to corresponding binary number  $0010\\ 1011 \\rightarrow 0x2B$   For hex to binary, just convert each hex digit to the corresponding group in binary  $0x2B \\rightarrow 0010\\ 1011$        Definitions  True = 1, False = 0 Everything eventually converted to either 1 or 0  Numbers: 19 base 10 = 10011 base 2 Letters: each character is assigned to a 8 bit number   Bits:  a single binary digit (0 or 1) The leftmost bit is the highest order bit The rightmost bit is the lowest order bit   Byte:  A group of 8 bits. e.g. (10110010)   Word:  a grouping of bits  computer-architecture dependent   The number of bits that the computer architecture can process at once  64-bit word architectures expect data in 64-bit groupings  The number of bits used by an architecture is called the word size     Common notation for k-bit value: $b_{k-1}b_{k-2}…b_{1}b_{0}$    Modular Arithmetic  Def: X mod Y = remainder (X/Y)  remainder constrained between 0 and Y-1 Alternative definition: remainder constrained between $-\\frac{Y}{2}$ and $\\frac{Y}{2}-1$ 100 mod 9 = 1 -10 mod 3 = -1 mod 3 = 2 mod 3  X mod Y = Z mod Y iff  $X = Z+KY$ for some integer K        Integer format with word size restriction  For a given number of digits, how many possible values can you represent?  $b^{d}$, where b is the base and d is the number of digits  For 2 bit word size: {00, 01, 10, 11}   As humans, we can assign whatever value to a distinct bit-sequence:  2 bit word size: {00: .234, 01:i, 10: 234, 11: asdf}  Nonsensical , but allowed        Unsigned binary numbers:  Positive integers of a fixed wordsize e.g. 1111 = 15 for a 4-bit word  Binary Addition Algorithm (BAA)  1+1 = 0 with a carry of 1 eg. wordsize = 5, add 11110 and 10101 (30+21)  11110+10101 = 10011 if restricted to 5 bits  Called overflow: when a result can’t fit within the wordsize constraint The correct answer needs 6 bits (110011)     The answer may not be correct because of overflow, but it is correct up to mod $b^{d}$  Negative numbers Signed Magnitude Representation  Let the highest order bit denote the sign of the number (0 is positive and 1 is negative)  e.g. 0011 = 3 e.g. 1011 = -3 e.g. 1000 = 0000 = 0   To negate, simply flip the highest order bit  1’s Complement  Again, highest order bit indicates sign (0 is positive and 1 is negative) To negate a value, flip all the bits  0010 = 2 1101 = -2   e.g. wordsize of 8, value is 11101001. 1’s Complement rep  We know its negative (1 in highest order) Negate all the bits and read off positive value, then slap on negative sign Using this, 11101001 = -20   000000 = 111111 are both 0 in 1’s complement  Problems with Signed Magnitude and 1’s Complement  0101+1101 = 0010 (after dropping carry of 1) Unsigned binary: 5+8 = 2 (correct mod 16) Signed magnitude: 5+ (-5) = 0 (not 2, even up to mod 16) 1’s complement: 5+(-2) = 3 (not 2, even up to mod 16) TL;DR Binary Addition Algorithm doesn’t work  2’s complement  highest order bit is still sign To negate a number, flip all the bits (like 1’s complement) then add 1 in binary (eg a 4 bit word size, you add 0001)  0010 = 2 so 1101+0001 = 1110 = -2 1101 = -3 so 0010+0001 = 0011 = 3 (works for negative)   0 is unique in 2’s complement (0000 = 1111+0001 = 0000) “100000” maps to itself in 2’s complement (largest negative number of the word size) 2’s complement always work with BAA (meaning that with any overflow, the result is off by mod $2^{wordsize}$)  Intuition behind 2’s complement  Let X be some word of size k Negate all the bits of X and call it Y  e.g. X = 100101, so Y = 011010 $X+Y$ using BAA always equals a a word of size k whose entries are entirely 1s  $X+Y$ = 111111   Adding the the decimal number 1 to $X+Y$ (ie 000001) causes overflow which yields a word of only zeros. So we can think of the operation of flipping all the bits and adding decimal 1 to a string as the negation of X    Lecture 2  The range of unsigned integers is 0 to $2^{k}-1$ The range of signed integers is $-2k^{k-1}$ to $2k^{k-1}$ A string if bits is useless unless you know what representation they represent (unsigned, signed ,ASCII, etc.) Representation: How you interpret the bits Operations: do something to the bits (independent of representation)  Why 2’s complement? Easy subtraction  Say that we want to find 001110-010101 in signed magnitude representation (14-21). It the same procedure as in base 10, but in base 2 (including carries) Instead, make the representation the 2’s complement  Negate 21, then apply BAA. You get the correct answer: 001110-010101=001110+101011=111001 (14-21=7)    Detecting Overflow  For 2’s complement:  Look at the final 2 carries from the BAA algorithm. If the carries are different, you have overflow  $00$ case: $5+1=6\\rightarrow 0101+0001=0110=6$ $11$ case: $-5-3=-8\\rightarrow 1011+1101=1000=-8$ $10$ case (overflow): $-2+-7=-9\\rightarrow 1110+1001=0111=7$ $01$ case (overflow): $7+7=14\\rightarrow 0111+0111=1110=-6$     Overflow just means that the result can’t be represented with the word size. It does not mean that the result is too big  Floating Points  Scientific notation:  -7.776E3. The number to the left of the E is called the mantissa. The number to the right is the exponent   In binary: $-1.10\\times2^{01111}= -1.5*2^{7}$  IEEE standard for a 32 bit word  highest order bit (31th) is the sign  0 is positive, 1 is negative   exponent is bit 30 to 23  represent the value as an unsigned binary, then subtract 127 (the bias)   Fraction (the rest of the bits)  represents 1.XXXXXX. The “1.” is implicit for all floating point numbers, including zero. The mantissa represent the numbers after the decimal    To approximate zero, you set all the bits to zero, which corresponds to $1.0*2^{-127}$, which is effectively zero  Doubles  A double uses two 32-bit words  There is one sign bit, 11 exponent bits, and 52 fraction bits The first word has the sign bit, the exponent bits and the rest are the higher order bits of the fraction The second word is the rest of the fraction The bias is 1023    Underflow  Say that we have a number X = 1E-83. Squaring X, we get Y = 1E-166. This cannot be represented as a float. This is referred to as underflow, which is a subcategory of overflow  Boolean Algebra  Either 0 or 1 (False or True)  Can represent as a variable (X,Y,A,B) Complement of X is denoted as $\\bar{X}$. This is just flipping a bit Literal a boolean variable or its complement  $\\cdot$ represents AND (can be omitted) + represents OR   Left to right precedence. parentheses give priority to operations You daisy chain operations on multiple values by constructing a truth table where each column represents an unsigned integer Expressions is a set of literals (possibly with repeats) combined with logic operations Equations expression1=expression2 Functions: Takes in some literals and outputs an expression  Boolean Algebra Identities  $X+XY=X$ $X(X+Y)=X$  Distributive Law Proof  $(X+Y)(X+Z) = XX+XZ+YX+YZ$ Apply $XX=X$, $X+XZ = X$, $X+YX=X$ sequentially to show final result  DeMorgan’s Theorem  Split the big bar at the operator Chance AND to OR and OR to AND Flip-flop literal 0 and 1 to each other Replace function F with the complement $\\bar{F}$ and vice versa  Consensus Theorem  $XY+\\bar{XZ}+YZ=XY+\\bar{X}Z$  If $YZ = 0$, then trivially you can drop $YZ$ If $YZ=1$  both $Y$ and $Z$ are 1. $XY+\\bar{X}Z+1 = 1$, so LHS is 1 Either $X$ or $\\bar{X}$. Since $Y=Z=1$, either $XY$ or $\\bar{X}Z$ is 1, so RHS is 1      circuit Representation of Boolean Algebra  The depth of a circuit refers to how the maximum layers are between the input and output If you want to have multiple inputs, put more lines as the input on the left  a k-input gate has a depth of $log_{2}(k)$    Coverting Circuits to Booleans  Start from the RHS and move left  As you pass each gate, write down the number of inputs in their own section Repeat until you get to your inputs    NAND and NOR  You invert the output of AND and OR respectively These are universal gates   XOR  XOR is denoted as $\\otimes$ (either the first or the second is true, but not both)  Used for parity control (how many of the inputs are true)  $Y\\otimes 0 = Y$ $Y\\otimes 1 = \\bar{Y}$ $X_{1}\\otimes X_{2}\\otimes…X_{k}=1$ when an odd number of $X_{i}=1$      Duals  All booleans expressions have duals. TO construct the dual:  Swap the ANDs and ORs, swap the literals 0 and 1 for each and rearrange the parentheses as needed    You can take the complement of a function by taking the dual, then negating all the literals  Lecture 3 Sum of Products (SoP)  Any function can be represented as a product of sums (ie. ORing ANDS together)  Do all the ANDs before the ORs   To calculate, expand out all the terms, then remove duplicates  G = X(Y+Z)(X+Y+Z) = XY+XZ    Product of Sums (PoS)  Any function can be represented as a sum of products (ie. ANDing many ORs together)  Do all the ORs before the ANDs    Convert SoP to PoS  onvert function $F$ to SoP. Take the compliment of SoP by taking the dual and then complementing the literals. This is PoS  Minterms  Minterm is a product term in which all variable appear exactly once (either complemented or uncomplemented)     You can refer to each minterm by the unsigned int that they represent (mX) A function can be described as a sum of its minterms  You can evauluate when the function is true by looking at the minterms   You can marginalize on a literal by including the minterms that include literal and its complement Minterm expansion is not a simplified form  Maxterms  The dual of minterms (ie a sum in which all variables appear exactly once, either complemented or uncomplemented) Denoted as MX The product expansion of a function in terms of maxterms  Whenever the function evaluates to zero, these inputs correspond to a particular maxterm in the expansion    Karnaugh Map  Say that you have $F = X+\\bar{X}Y$. How do you simplify this?  Replace $X = X+XY$ and turn the crank to get $F=X+Y$ Not immediately obvious. Need an automatic tool to help Not the simplest form, but good enough    Expand the truth table into a 2D grid indexed Y horizontally and X vertically (origin from the top-left and moves right and down)  Each value of the input literal tells you where on the Karnaugh Map    Let the vertical axis be X, and the horizontal be YZ  Gray encoding: order values of YZ such that only one bit changes at a time Y goes on top, Z goes on bottom     Minterm product terms correspond to a $2^{i} \\times 2^{j}$ rectangle (including wraparounds)  To find the simplest form you can derive from the k-map, you draw the largest rectangles you can (incluing wraparounds) and then relate these rectangles to products     K-map Notation  Implicant: a product term comprised of minterms for which the function F evaluates to 1 (ie. a box whose dimensions are powers of 2) Prime Implicant: there exists no other implicant that can contain this implicant Essential Prime Implicant: this implicant covers at least one minterm that is not covered by any other prime implicant   Summary of Simplification with k-maps  Identify all the prime and essential prime implicants  Include all the essential PIs If any 1-valued minterms are uncovered by EPIs, choose PIs that are “big” and do a good job covering  Heuristic: Choose the PIs that minimize overlap with one another and with EPIs      2-bit multiplier  You have 2 2 bit numbers. You need 4 bits to represent the largest product Each bit in the output can be written as a k-map, which can be simplified to write what inputs correspond to this particular output bit getting turned on  Don’t Care Conditions  These are circumstances where the output doesn’t matter  Going to the 2-bit multiplier, say that you know that some set of inputs will never occur. Hence you can ignore the output of those inputs when building a circuit   Denote X as the outputs where you don’t care about the output In the k-map, replace the don’t care conditions with X. You can optionally cover X’s with EPI’s (ie. you can include X’s in larger boxes to simplify circuitry)  Drawing Circuits  Denote a circuit as a blob so you don’t have to redraw a circuit over and over again When an input changes, it takes time for the output to get updated  Lecture 4 Standard Circuits  NB: Think about circuits as having constant input  Enabler  Takes in data D (k bits in parallel), as well as an enable/disable trigger E. There is a single output of k bits  If E=1, the output equals the input If E=0, output equals k 0’s    Implement enabler with k AND gates. Each input has it’s own AND gate, and the other pin is the Enable input   Decoder Circuit  Takes in a k-bit input and $2^{k}$ 1-bit outputs The selector indicates as an unsigned binary which output = 1. All other outputs are zero  Write truth table out. Each row is a minterm. Recall that each minterm evaluates for 1 for a unique combination of literals. You can write decoders with a combination of NOTs and ANDs  Decoder With Enable  Slap the two previous circuits together Push the output of the decoder through k AND gates where every AND gate has a input connected to the enable pin   MUX (Multiplexer)  Takes $2^{k}$ 1-bit data values as input. Has a k-bit selector that indicates in unsigned binary which data bit is output You push all the data values in as input simultaneously, and only the one you select is the output. All other inputs are dropped  You have a selector part that chooses which input to select You pass all this data to an enabler, whose output gets passed to an OR gate    Representing Functions with Decoders and MUXes  Use a Decoder and OR together the minterms that evaluate to 1 of your function Use a Multiplexer where you feed in the output of your function. The input to the multiplexer is the values that your literals you take. The output is then your function  MUX trick  Look at your truth table in pairs of rows. You can select on A and B as the selector input. You pass the C input as one of the the $2^{k}$ 1-bit inputs and it’s complement  Shifter Circuit  k-bit data value enter as input l-bit selector in unsigned binary tells how many bits to shift k-bit output where bits are shifted by l-bits (can wraparound or drop out)   Barrel Shift left w/ Wraparound  Say you want to shift over by 2 with wrap around You use MUXes. Each output bit of the MUX goes to the output of the Shifter. All the MUXes have the same shift bit as their selector   L-R Shift Circuit with Rollout Unsigned Adder Circuit  Two k-bit data values (A,B) and 1 bit carry in bit $C_{in}$ output is k-bit of $A+B+C_{in}$ and a carry out bit $_{out}$   Half-Adder  Takes two inputs A and B and returns a Sum and a carry  The sum is computed via XOR and the carry is computed by AND    Full-Adder  Takes as input 2 digits (A\u0026B) and previous carry (P) Can daisy chain full adders together  Each subsequent adder needs to wait until the previous adder to finish    Signed Adder/Subtractor (2’s-C) Ripple Carry Adder  Two k-bit data values and 1 bit S (0 for add, 1 for subtract) Output is k-bit $A+B$ when S is 0 and $A-B$ when S is 1  You also have an overflow bit    To calculate A-B, first flip B by XORing with 1 prior to sending the output of the XORs to a full adder with an initial carry of 1 Overflow can be calculated by XORing the highest order bits of the adder  Optimizing Ripple Carry (Carry Lookahead)  We try to parallelize the carry operations When do we get carries If the ith bit of A and B are the same (11 or 00), then you are guaranteed to either have a carry or not have a carry respectively if the bits are different, what happens?  There is a carry iff the previous column has a carry $C_{i+1} = A_{i}B_{i}+(A_{i}\\otimes B_{i})A_{i-1}B_{i-1}$ This can be recursively expanded to the lowest order bit    Merge with known 0’s  Suppose we have m input signals We know all of them except one is zero. The remaining bit could be zero or one. You also don’t know which one is the unknown bit Implement with an OR gate   Code Converter  Say that you want to build a circuit to light up a LED number. Denote each segment of the LED with a letter Take in as input 4 variables WXYZ and output which segments to light up Look at each column of the truth table, build a k-map from the column and then build a circuit  Contraction  Say that you have a circuit. Now you know that some inputs are fixed. YOu can simplify the circuit  Example 1  For an incrementor (add one to current value), you can replace full adder with half adders and be careful with the lowest order bit   Lecture 5 Latch Intuition  You a data bit X(t), a write bit W(t) and outputs of Q and complement of Q  If w is 1, then the Q follows X If w equals 0, then Q maintains its current output, regardless of the input     SR Latch  We have a reset pin (R), a set pin (S), and output and inverted outputs (Q and $\\bar{Q}$)  implemented with NOR gates    R = 1 and S =1 produces garbage You can also construct a $\\bar{S}\\bar{R}$ Latch with NAND gates, where S=0 and R=0 is garbage instead  SR Latch with Control  We have S,R, and C being fed into NAND Gates, whose outputs get feed into $\\bar{S}\\bar{R}$ latch. C controls wheather the latch is enabled or not. If the latch is not enabled, it defaults to holding its current value  D Latch with control  You have D and C being feed int NAND gates, where you invert one of the C inputs. The results are feed into an $\\bar{S}\\bar{R}$ latch. Implementation of intuitive idea of latch   ",
  "wordCount" : "3620",
  "inLanguage": "en",
  "datePublished": "2023-01-17T22:19:34-05:00",
  "dateModified": "2023-02-13T13:51:49-05:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mushetty.me/notes/fundies/fundies/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "mushetty.me",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mushetty.me/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mushetty.me" accesskey="h" title="mushetty.me (Alt + H)">mushetty.me</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://mushetty.me/simulations/" title="Simulations">
                    <span>Simulations</span>
                </a>
            </li>
            <li>
                <a href="https://mushetty.me/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://mushetty.me/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Fundamentals of Computer Systems
    </h1>
    <div class="post-meta"><span title='2023-01-17 22:19:34 -0500 EST'>Date Created: January 17, 2023</span>&nbsp;·&nbsp;<span title='2023-02-13 13:51:49 -0500 EST'>Last Modified: February 13, 2023</span>

</div>
  </header> 
  <div class="post-content"><p>Compilation of notes for Fundamentals of Computer Systems class for Spring 2023.</p>
<ul>
<li><a href="#administrative-stuff">Administrative Stuff</a>
<ul>
<li><a href="#exams">Exams</a></li>
<li><a href="#grades">Grades</a></li>
</ul>
</li>
<li><a href="#lecture-0">Lecture 0</a></li>
<li><a href="#lecture-1">Lecture 1</a>
<ul>
<li><a href="#cpu-models">CPU Models</a></li>
<li><a href="#addition-in-different-bases">Addition in different bases</a></li>
<li><a href="#definitions">Definitions</a></li>
<li><a href="#modular-arithmetic">Modular Arithmetic</a></li>
<li><a href="#integer-format-with-word-size-restriction">Integer format with word size restriction</a>
<ul>
<li><a href="#unsigned-binary-numbers">Unsigned binary numbers:</a>
<ul>
<li><a href="#binary-addition-algorithm-baa">Binary Addition Algorithm (BAA)</a></li>
</ul>
</li>
<li><a href="#negative-numbers">Negative numbers</a>
<ul>
<li><a href="#signed-magnitude-representation">Signed Magnitude Representation</a></li>
<li><a href="#1s-complement">1&rsquo;s Complement</a></li>
<li><a href="#problems-with-signed-magnitude-and-1s-complement">Problems with Signed Magnitude and 1&rsquo;s Complement</a></li>
<li><a href="#2s-complement">2&rsquo;s complement</a></li>
<li><a href="#intuition-behind-2s-complement">Intuition behind 2&rsquo;s complement</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#lecture-2">Lecture 2</a>
<ul>
<li><a href="#why-2s-complement">Why 2&rsquo;s complement?</a>
<ul>
<li><a href="#easy-subtraction">Easy subtraction</a></li>
<li><a href="#detecting-overflow">Detecting Overflow</a></li>
</ul>
</li>
<li><a href="#floating-points">Floating Points</a>
<ul>
<li><a href="#ieee-standard-for-a-32-bit-word">IEEE standard for a 32 bit word</a></li>
<li><a href="#doubles">Doubles</a></li>
<li><a href="#underflow">Underflow</a></li>
</ul>
</li>
<li><a href="#boolean-algebra">Boolean Algebra</a>
<ul>
<li><a href="#boolean-algebra-identities">Boolean Algebra Identities</a>
<ul>
<li><a href="#distributive-law-proof">Distributive Law Proof</a></li>
<li><a href="#demorgans-theorem">DeMorgan&rsquo;s Theorem</a></li>
<li><a href="#consensus-theorem">Consensus Theorem</a></li>
<li><a href="#circuit-representation-of-boolean-algebra">circuit Representation of Boolean Algebra</a>
<ul>
<li><a href="#coverting--circuits-to-booleans">Coverting  Circuits to Booleans</a></li>
</ul>
</li>
<li><a href="#nand-and-nor">NAND and NOR</a></li>
</ul>
</li>
<li><a href="#xor">XOR</a></li>
</ul>
</li>
<li><a href="#duals">Duals</a></li>
</ul>
</li>
<li><a href="#lecture-3">Lecture 3</a>
<ul>
<li><a href="#sum-of-products-sop">Sum of Products (SoP)</a></li>
<li><a href="#product-of-sums-pos">Product of Sums (PoS)</a>
<ul>
<li><a href="#convert-sop-to-pos">Convert SoP to PoS</a></li>
</ul>
</li>
<li><a href="#minterms">Minterms</a></li>
<li><a href="#maxterms">Maxterms</a></li>
<li><a href="#karnaugh-map">Karnaugh Map</a>
<ul>
<li><a href="#k-map-notation">K-map Notation</a></li>
<li><a href="#summary-of-simplification-with-k-maps">Summary of Simplification with k-maps</a></li>
<li><a href="#2-bit-multiplier">2-bit multiplier</a></li>
<li><a href="#dont-care-conditions">Don&rsquo;t Care Conditions</a></li>
</ul>
</li>
<li><a href="#drawing-circuits">Drawing Circuits</a></li>
</ul>
</li>
<li><a href="#lecture-4">Lecture 4</a>
<ul>
<li><a href="#standard-circuits">Standard Circuits</a>
<ul>
<li><a href="#enabler">Enabler</a></li>
<li><a href="#decoder-circuit">Decoder Circuit</a></li>
<li><a href="#decoder-with-enable">Decoder With Enable</a></li>
<li><a href="#mux-multiplexer">MUX (Multiplexer)</a>
<ul>
<li><a href="#representing-functions-with-decoders-and-muxes">Representing Functions with Decoders and MUXes</a></li>
<li><a href="#mux-trick">MUX trick</a></li>
</ul>
</li>
<li><a href="#shifter-circuit">Shifter Circuit</a>
<ul>
<li><a href="#barrel-shift-left-w-wraparound">Barrel Shift left w/ Wraparound</a></li>
<li><a href="#l-r-shift-circuit-with-rollout">L-R Shift Circuit with Rollout</a></li>
</ul>
</li>
<li><a href="#unsigned-adder-circuit">Unsigned Adder Circuit</a>
<ul>
<li><a href="#half-adder">Half-Adder</a></li>
<li><a href="#full-adder">Full-Adder</a></li>
</ul>
</li>
<li><a href="#signed-addersubtractor-2s-c">Signed Adder/Subtractor (2&rsquo;s-C)</a>
<ul>
<li><a href="#ripple-carry-adder">Ripple Carry Adder</a></li>
<li><a href="#optimizing-ripple-carry-carry-lookahead">Optimizing Ripple Carry (Carry Lookahead)</a></li>
</ul>
</li>
<li><a href="#merge-with-known-0s">Merge with known 0&rsquo;s</a></li>
<li><a href="#code-converter">Code Converter</a></li>
<li><a href="#contraction">Contraction</a>
<ul>
<li><a href="#example-1">Example 1</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#lecture-5">Lecture 5</a>
<ul>
<li><a href="#latch-intuition">Latch Intuition</a></li>
<li><a href="#sr-latch">SR Latch</a></li>
<li><a href="#sr-latch-with-control">SR Latch with Control</a></li>
<li><a href="#d-latch-with-control">D Latch with control</a></li>
<li><a href="#"></a></li>
</ul>
</li>
</ul>
<h2 id="administrative-stuff">Administrative Stuff<a hidden class="anchor" aria-hidden="true" href="#administrative-stuff">#</a></h2>
<h3 id="exams">Exams<a hidden class="anchor" aria-hidden="true" href="#exams">#</a></h3>
<ul>
<li>Midterm: On March 8th, 6-9 pm (tentative)
<ul>
<li>Check for conflicts</li>
</ul>
</li>
<li>End-of-term exam: Either April 27, evening (6-9 pm) or May 5 in the evening</li>
<li>Fill in exam conflicts (by 1/24)
<ul>
<li>Acceptable excuses: conflicting classes and religious conflicts</li>
</ul>
</li>
<li>Fill in P-credit office hours (By 1/21)
<ul>
<li>Go to web form</li>
<li>The top row indicates the start time of the office hours (e.g. 12 means 12-1. 12:30 means 12:30-1)</li>
<li>Need at least 10 hours selected</li>
</ul>
</li>
<li>Email for help: 3827-staff[at]googlegroups.com
<ul>
<li><strong>Include 3827 in subject header. Otherwise, it will get overlooked</strong></li>
</ul>
</li>
<li>Use EdStem for class updates instead of Courseworks, as well as to ask questions b/c it will be faster than email</li>
</ul>
<h3 id="grades">Grades<a hidden class="anchor" aria-hidden="true" href="#grades">#</a></h3>
<ul>
<li>TL;DR Do Homework, go to office hours, don&rsquo;t bomb the midterm or final</li>
</ul>
<h2 id="lecture-0">Lecture 0<a hidden class="anchor" aria-hidden="true" href="#lecture-0">#</a></h2>
<ul>
<li>Work on HW0 (Not graded)</li>
<li>Why should I care about this course?
<ul>
<li>Shows how computers run &ldquo;under the hood&rdquo;</li>
<li>Learn &ldquo;parallel thinking&rdquo;
<ul>
<li>Humans think sequentially</li>
<li>Circuits run multiple &ldquo;threads&rdquo; at once</li>
</ul>
</li>
<li>Useful to understand these ideas in many domains
<ul>
<li>Systems</li>
<li>Programming Languages (Compilers and Interpreters)</li>
<li>Quantum Computing</li>
<li>ML/AI</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="lecture-1">Lecture 1<a hidden class="anchor" aria-hidden="true" href="#lecture-1">#</a></h2>
<h3 id="cpu-models">CPU Models<a hidden class="anchor" aria-hidden="true" href="#cpu-models">#</a></h3>
<p><img loading="lazy" src="/images/Fundie/CPUDiagram.png" alt="CPU Diagram"  />
</p>
<ul>
<li>CPU: &ldquo;brain&rdquo; of the computer
<ul>
<li>Control Unit: D oes calculations on data in <strong>datapath</strong></li>
</ul>
</li>
<li>Memory: Stores data (for later use)</li>
<li>I/O: Interface to the outside (disk, network, monitor, keyboard, mouse, etc.)</li>
<li>Simpler model of CPU:
<img loading="lazy" src="/images/Fundie/SimpleComputer.png" alt="SimpleCPU"  />

<ul>
<li>Discrete inputs (over time)</li>
<li>Discrete Information Processing System
<ul>
<li>communicates with System state and output something based on input</li>
</ul>
</li>
<li>System State
<ul>
<li>Remembers previous information</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="addition-in-different-bases">Addition in different bases<a hidden class="anchor" aria-hidden="true" href="#addition-in-different-bases">#</a></h3>
<ul>
<li>humans: 10 digits: {0,1,2,3,4,5,6,7,8,9}
<ul>
<li>$(4537.8)_{10} = 4*10^{3}+5*10^{2}+3*10{1}+7*10^{0}+8*10^{-1}$</li>
<li>Shifting everything to the left is multiplication by 10</li>
</ul>
</li>
<li>computers: 2 digits: {0,1}
<ul>
<li>$(1011.1)_{2} = 1*2^{3}+0*2^{2}+1*2^{1}+1*2^{0}+1*2^{-1} = 11.5$</li>
<li>Shifting everything to the left multiplies by 2</li>
</ul>
</li>
<li>Hex: 16 digits {0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F}
<ul>
<li>Hex numbers specified as 0x26BA</li>
<li>$0x26BA = 2*16^{3}+6*16^{2}+11*16^{1}+10*16^{0} = (9914)_{10}$</li>
<li>We use hex since it is more human readable and is easy to convert to and from binary
<ul>
<li>a base-2 4 digit can be multiplied by 16 by shifting 4 to the left ($1100 \rightarrow 1100\ 0000$)</li>
<li>a base-16 1 digit can be multiplied by 16 by shifting 1 to the left ($0xD \rightarrow 0xD0$)</li>
<li>To convert binary to hex, break hex into groups of 4 and convert each group to corresponding binary number
<ul>
<li>$0010\ 1011 \rightarrow 0x2B$</li>
</ul>
</li>
<li>For hex to binary, just convert each hex digit to the corresponding group in binary
<ul>
<li>$0x2B \rightarrow 0010\ 1011$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="definitions">Definitions<a hidden class="anchor" aria-hidden="true" href="#definitions">#</a></h3>
<ul>
<li>True = 1, False = 0</li>
<li>Everything eventually converted to either 1 or 0
<ul>
<li>Numbers: 19 base 10 = 10011 base 2</li>
<li>Letters: each character is assigned to a 8 bit number</li>
</ul>
</li>
<li>Bits:
<ul>
<li>a single binary digit (0 or 1)</li>
<li>The leftmost bit is the <strong>highest order</strong> bit</li>
<li>The rightmost bit is the <strong>lowest order</strong> bit</li>
</ul>
</li>
<li>Byte:
<ul>
<li>A group of 8 bits. e.g. (10110010)</li>
</ul>
</li>
<li>Word:
<ul>
<li>a grouping of bits
<ul>
<li>computer-architecture dependent</li>
</ul>
</li>
<li>The number of bits that the computer architecture can process at once
<ul>
<li>64-bit word architectures expect data in 64-bit groupings
<ul>
<li>The number of bits used by an architecture is called the <strong>word size</strong></li>
</ul>
</li>
</ul>
</li>
<li>Common notation for k-bit value: $b_{k-1}b_{k-2}&hellip;b_{1}b_{0}$</li>
</ul>
</li>
</ul>
<h3 id="modular-arithmetic">Modular Arithmetic<a hidden class="anchor" aria-hidden="true" href="#modular-arithmetic">#</a></h3>
<ul>
<li>Def: X mod Y = remainder (X/Y)
<ul>
<li>remainder constrained between 0 and Y-1</li>
<li>Alternative definition: remainder constrained between $-\frac{Y}{2}$ and $\frac{Y}{2}-1$</li>
<li>100 mod 9 = 1</li>
<li>-10 mod 3 = -1 mod 3 = 2 mod 3
<ul>
<li>X mod Y = Z mod Y iff
<ul>
<li>$X = Z+KY$ for some integer K</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="integer-format-with-word-size-restriction">Integer format with word size restriction<a hidden class="anchor" aria-hidden="true" href="#integer-format-with-word-size-restriction">#</a></h3>
<ul>
<li>For a given number of digits, how many possible values can you represent?
<ul>
<li>$b^{d}$, where b is the base and d is the number of digits
<ul>
<li>For 2 bit word size: {00, 01, 10, 11}</li>
</ul>
</li>
<li>As humans, we can assign whatever value to a distinct bit-sequence:
<ul>
<li>2 bit word size: {00: .234, 01:i, 10: 234, 11: asdf}
<ul>
<li>Nonsensical , but allowed</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="unsigned-binary-numbers">Unsigned binary numbers:<a hidden class="anchor" aria-hidden="true" href="#unsigned-binary-numbers">#</a></h4>
<ul>
<li>Positive integers of a fixed wordsize</li>
<li>e.g. 1111 = 15 for a 4-bit word</li>
</ul>
<h5 id="binary-addition-algorithm-baa">Binary Addition Algorithm (BAA)<a hidden class="anchor" aria-hidden="true" href="#binary-addition-algorithm-baa">#</a></h5>
<ul>
<li>1+1 = 0 with a carry of 1</li>
<li>eg. wordsize = 5, add 11110 and 10101 (30+21)
<ul>
<li>11110+10101 = 10011 if restricted to 5 bits
<ul>
<li>Called <strong>overflow</strong>: when a result can&rsquo;t fit within the wordsize constraint</li>
<li>The correct answer needs 6 bits (110011)</li>
</ul>
</li>
</ul>
</li>
<li>The answer may not be correct because of overflow, but it is correct up to mod $b^{d}$</li>
</ul>
<h4 id="negative-numbers">Negative numbers<a hidden class="anchor" aria-hidden="true" href="#negative-numbers">#</a></h4>
<h5 id="signed-magnitude-representation">Signed Magnitude Representation<a hidden class="anchor" aria-hidden="true" href="#signed-magnitude-representation">#</a></h5>
<ul>
<li>Let the highest order bit denote the sign of the number (0 is positive and 1 is negative)
<ul>
<li>e.g. 0011 = 3</li>
<li>e.g. 1011 = -3</li>
<li>e.g. 1000 = 0000 = 0</li>
</ul>
</li>
<li>To negate, simply flip the highest order bit</li>
</ul>
<h5 id="1s-complement">1&rsquo;s Complement<a hidden class="anchor" aria-hidden="true" href="#1s-complement">#</a></h5>
<ul>
<li>Again, highest order bit indicates sign (0 is positive and 1 is negative)</li>
<li>To negate a value, flip all the bits
<ul>
<li>0010 = 2</li>
<li>1101 = -2</li>
</ul>
</li>
<li>e.g. wordsize of 8, value is 11101001. 1&rsquo;s Complement rep
<ul>
<li>We know its negative (1 in highest order)</li>
<li>Negate all the bits and read off positive value, then slap on negative sign</li>
<li>Using this, 11101001 = -20</li>
</ul>
</li>
<li>000000 = 111111 are both 0 in 1&rsquo;s complement</li>
</ul>
<h5 id="problems-with-signed-magnitude-and-1s-complement">Problems with Signed Magnitude and 1&rsquo;s Complement<a hidden class="anchor" aria-hidden="true" href="#problems-with-signed-magnitude-and-1s-complement">#</a></h5>
<ul>
<li>0101+1101 = 0010 (after dropping carry of 1)</li>
<li>Unsigned binary: 5+8 = 2 (correct mod 16)</li>
<li>Signed magnitude: 5+ (-5) = 0 (not 2, even up to mod 16)</li>
<li>1&rsquo;s complement: 5+(-2) = 3 (not 2, even up to mod 16)</li>
<li>TL;DR Binary Addition Algorithm doesn&rsquo;t work</li>
</ul>
<h5 id="2s-complement">2&rsquo;s complement<a hidden class="anchor" aria-hidden="true" href="#2s-complement">#</a></h5>
<ul>
<li>highest order bit is still sign</li>
<li>To negate a number, flip all the bits (like 1&rsquo;s complement) then add 1 in binary (eg a 4 bit word size, you add 0001)
<ul>
<li>0010 = 2 so 1101+0001 = 1110 = -2</li>
<li>1101 = -3 so 0010+0001 = 0011 = 3 (works for negative)</li>
</ul>
</li>
<li>0 is unique in 2&rsquo;s complement (0000 = 1111+0001 = 0000)</li>
<li>&ldquo;100000&rdquo; maps to itself in 2&rsquo;s complement (largest negative number of the word size)</li>
<li>2&rsquo;s complement always work with BAA (meaning that with any overflow, the result is off by mod $2^{wordsize}$)</li>
</ul>
<h5 id="intuition-behind-2s-complement">Intuition behind 2&rsquo;s complement<a hidden class="anchor" aria-hidden="true" href="#intuition-behind-2s-complement">#</a></h5>
<ul>
<li>Let X be some word of size k</li>
<li>Negate all the bits of X and call it Y
<ul>
<li>e.g. X = 100101, so Y = 011010</li>
<li>$X+Y$ using BAA always equals a a word of size k whose entries are entirely 1s
<ul>
<li>$X+Y$ = 111111</li>
</ul>
</li>
<li>Adding the the decimal number 1 to $X+Y$ (ie 000001) causes overflow which yields a word of only zeros.</li>
<li>So we can think of the operation of flipping all the bits and adding decimal 1 to a string as the negation of X</li>
</ul>
</li>
</ul>
<h2 id="lecture-2">Lecture 2<a hidden class="anchor" aria-hidden="true" href="#lecture-2">#</a></h2>
<ul>
<li>The range of unsigned integers is 0 to $2^{k}-1$</li>
<li>The range of signed integers is $-2k^{k-1}$ to $2k^{k-1}$</li>
<li>A string if bits is useless unless you know what representation they represent (unsigned, signed ,ASCII, etc.)</li>
<li>Representation: How you interpret the bits</li>
<li>Operations: do something to the bits (independent of representation)</li>
</ul>
<h3 id="why-2s-complement">Why 2&rsquo;s complement?<a hidden class="anchor" aria-hidden="true" href="#why-2s-complement">#</a></h3>
<h4 id="easy-subtraction">Easy subtraction<a hidden class="anchor" aria-hidden="true" href="#easy-subtraction">#</a></h4>
<ul>
<li>Say that we want to find 001110-010101 in signed magnitude representation (14-21). It the same procedure as in base 10, but in base 2 (including carries)</li>
<li>Instead, make the representation the 2&rsquo;s complement
<ul>
<li>Negate 21, then apply BAA. You get the correct answer: 001110-010101=001110+101011=111001 (14-21=7)</li>
</ul>
</li>
</ul>
<h4 id="detecting-overflow">Detecting Overflow<a hidden class="anchor" aria-hidden="true" href="#detecting-overflow">#</a></h4>
<ul>
<li>For 2&rsquo;s complement:
<ul>
<li>Look at the final 2 carries from the BAA algorithm. If the carries are different, you have overflow
<ul>
<li>$00$ case: $5+1=6\rightarrow 0101+0001=0110=6$</li>
<li>$11$ case: $-5-3=-8\rightarrow 1011+1101=1000=-8$</li>
<li>$10$ case (overflow): $-2+-7=-9\rightarrow 1110+1001=0111=7$</li>
<li>$01$ case (overflow): $7+7=14\rightarrow 0111+0111=1110=-6$</li>
</ul>
</li>
</ul>
</li>
<li><strong>Overflow</strong> just means that the result can&rsquo;t be represented with the word size. It does not mean that the result is too big</li>
</ul>
<h3 id="floating-points">Floating Points<a hidden class="anchor" aria-hidden="true" href="#floating-points">#</a></h3>
<ul>
<li>Scientific notation:
<ul>
<li>-7.776E3. The number to the left of the E is called the mantissa. The number to the right is the exponent</li>
</ul>
</li>
<li>In binary: $-1.10\times2^{01111}= -1.5*2^{7}$</li>
</ul>
<h4 id="ieee-standard-for-a-32-bit-word">IEEE standard for a 32 bit word<a hidden class="anchor" aria-hidden="true" href="#ieee-standard-for-a-32-bit-word">#</a></h4>
<ul>
<li>highest order bit (31th) is the sign
<ul>
<li>0 is positive, 1 is negative</li>
</ul>
</li>
<li>exponent is bit 30 to 23
<ul>
<li>represent the value as an unsigned binary, then subtract 127 (the bias)</li>
</ul>
</li>
<li>Fraction (the rest of the bits)
<ul>
<li>represents 1.XXXXXX. The &ldquo;1.&rdquo; is implicit for all floating point numbers, including zero. The mantissa represent the numbers after the decimal
<img loading="lazy" src="/images/Fundie/IEEEStandardFloat.png" alt="IEEEStandard"  />
</li>
</ul>
</li>
<li>To approximate zero, you set all the bits to zero, which corresponds to $1.0*2^{-127}$, which is effectively zero</li>
</ul>
<h4 id="doubles">Doubles<a hidden class="anchor" aria-hidden="true" href="#doubles">#</a></h4>
<ul>
<li>A double uses two 32-bit words
<img loading="lazy" src="/images/Fundie/DoubleStandard.png" alt="doubleRepresentation"  />

<ul>
<li>There is one sign bit, 11 exponent bits, and 52 fraction bits</li>
<li>The first word has the sign bit, the exponent bits and the rest are the higher order bits of the fraction</li>
<li>The second word is the rest of the fraction</li>
<li>The bias is 1023</li>
</ul>
</li>
</ul>
<h4 id="underflow">Underflow<a hidden class="anchor" aria-hidden="true" href="#underflow">#</a></h4>
<ul>
<li>Say that we have a number X = 1E-83. Squaring X, we get Y = 1E-166. This cannot be represented as a float. This is referred to as underflow, which is a subcategory of overflow</li>
</ul>
<h3 id="boolean-algebra">Boolean Algebra<a hidden class="anchor" aria-hidden="true" href="#boolean-algebra">#</a></h3>
<ul>
<li>Either 0 or 1 (False or True)
<ul>
<li>Can represent as a variable (X,Y,A,B)</li>
<li><strong>Complement</strong> of X is denoted as $\bar{X}$. This is just flipping a bit</li>
<li><strong>Literal</strong> a boolean variable or its complement
<img loading="lazy" src="/images/Fundie/BasicTruthTables.png" alt="Basic Truth Tables"  />
</li>
<li>$\cdot$ represents AND (can be omitted)</li>
<li>+ represents OR</li>
</ul>
</li>
<li>Left to right precedence. parentheses give priority to operations</li>
<li>You daisy chain operations on multiple values by constructing a truth table where each column represents an unsigned integer</li>
<li><strong>Expressions</strong> is a set of literals (possibly with repeats) combined with logic operations</li>
<li><strong>Equations</strong> expression1=expression2</li>
<li><strong>Functions</strong>: Takes in some literals and outputs an expression</li>
</ul>
<h4 id="boolean-algebra-identities">Boolean Algebra Identities<a hidden class="anchor" aria-hidden="true" href="#boolean-algebra-identities">#</a></h4>
<p><img loading="lazy" src="/images/Fundie/BooleanIdentities.png" alt="Boolean Identities"  />
</p>
<ul>
<li>$X+XY=X$</li>
<li>$X(X+Y)=X$</li>
</ul>
<h5 id="distributive-law-proof">Distributive Law Proof<a hidden class="anchor" aria-hidden="true" href="#distributive-law-proof">#</a></h5>
<ul>
<li>$(X+Y)(X+Z) = XX+XZ+YX+YZ$</li>
<li>Apply $XX=X$, $X+XZ = X$, $X+YX=X$ sequentially to show final result</li>
</ul>
<h5 id="demorgans-theorem">DeMorgan&rsquo;s Theorem<a hidden class="anchor" aria-hidden="true" href="#demorgans-theorem">#</a></h5>
<ul>
<li>Split the big bar at the operator</li>
<li>Chance AND to OR and OR to AND</li>
<li>Flip-flop literal 0 and 1 to each other</li>
<li>Replace function F with the complement $\bar{F}$ and vice versa</li>
</ul>
<h5 id="consensus-theorem">Consensus Theorem<a hidden class="anchor" aria-hidden="true" href="#consensus-theorem">#</a></h5>
<ul>
<li>$XY+\bar{XZ}+YZ=XY+\bar{X}Z$
<ul>
<li>If $YZ = 0$, then trivially you can drop $YZ$</li>
<li>If $YZ=1$
<ul>
<li>both $Y$ and $Z$ are 1. $XY+\bar{X}Z+1 = 1$, so LHS is 1</li>
<li>Either $X$ or $\bar{X}$. Since $Y=Z=1$, either $XY$ or $\bar{X}Z$ is 1, so RHS is 1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="circuit-representation-of-boolean-algebra">circuit Representation of Boolean Algebra<a hidden class="anchor" aria-hidden="true" href="#circuit-representation-of-boolean-algebra">#</a></h5>
<p><img loading="lazy" src="/images/Fundie/CircuitRep.png" alt="PhysicalCircuits"  />
</p>
<ul>
<li>The depth of a circuit refers to how the maximum layers are between the input and output</li>
<li>If you want to have multiple inputs, put more lines as the input on the left
<ul>
<li>a k-input gate has a depth of $log_{2}(k)$</li>
</ul>
</li>
</ul>
<h6 id="coverting--circuits-to-booleans">Coverting  Circuits to Booleans<a hidden class="anchor" aria-hidden="true" href="#coverting--circuits-to-booleans">#</a></h6>
<p><img loading="lazy" src="/images/Fundie/CircuitSimplify.png" alt="ReadingCircuits"  />
</p>
<ul>
<li>Start from the RHS and move left
<ul>
<li>As you pass each gate, write down the number of inputs in their own section</li>
<li>Repeat until you get to your inputs</li>
</ul>
</li>
</ul>
<h5 id="nand-and-nor">NAND and NOR<a hidden class="anchor" aria-hidden="true" href="#nand-and-nor">#</a></h5>
<p><img loading="lazy" src="/images/Fundie/NANDNOR.png" alt="NAND and NOR Tables"  />
</p>
<ul>
<li>You invert the output of AND and OR respectively</li>
<li>These are universal gates
<img loading="lazy" src="/images/Fundie/BasicFromUniversal.png" alt="BasicFromUniversal"  />
</li>
</ul>
<h4 id="xor">XOR<a hidden class="anchor" aria-hidden="true" href="#xor">#</a></h4>
<ul>
<li>XOR is denoted as $\otimes$ (either the first or the second is true, but not both)
<img loading="lazy" src="/images/Fundie/XOR.png" alt="XORTable"  />

<ul>
<li>Used for parity control (how many of the inputs are true)
<ul>
<li>$Y\otimes 0 = Y$</li>
<li>$Y\otimes 1 = \bar{Y}$</li>
<li>$X_{1}\otimes X_{2}\otimes&hellip;X_{k}=1$ when an odd number of $X_{i}=1$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="duals">Duals<a hidden class="anchor" aria-hidden="true" href="#duals">#</a></h3>
<ul>
<li>All booleans expressions have <strong>duals</strong>. TO construct the dual:
<ul>
<li>Swap the ANDs and ORs, swap the literals 0 and 1 for each and rearrange the parentheses as needed
<img loading="lazy" src="/images/Fundie/Duals.png" alt="Duals"  />
</li>
</ul>
</li>
<li>You can take the complement of a function by taking the dual, then negating all the literals</li>
</ul>
<h2 id="lecture-3">Lecture 3<a hidden class="anchor" aria-hidden="true" href="#lecture-3">#</a></h2>
<h3 id="sum-of-products-sop">Sum of Products (SoP)<a hidden class="anchor" aria-hidden="true" href="#sum-of-products-sop">#</a></h3>
<ul>
<li>Any function can be represented as a product of sums (ie. ORing ANDS together)
<ul>
<li>Do all the ANDs before the ORs</li>
</ul>
</li>
<li>To calculate, expand out all the terms, then remove duplicates
<ul>
<li>G = X(Y+Z)(X+Y+Z) = XY+XZ</li>
</ul>
</li>
</ul>
<h3 id="product-of-sums-pos">Product of Sums (PoS)<a hidden class="anchor" aria-hidden="true" href="#product-of-sums-pos">#</a></h3>
<ul>
<li>Any function can be represented as a sum of products (ie. ANDing many ORs together)
<ul>
<li>Do all the ORs before the ANDs</li>
</ul>
</li>
</ul>
<h4 id="convert-sop-to-pos">Convert SoP to PoS<a hidden class="anchor" aria-hidden="true" href="#convert-sop-to-pos">#</a></h4>
<ul>
<li>onvert function $F$ to SoP. Take the compliment of SoP by taking the dual and then complementing the literals. This is PoS</li>
</ul>
<h3 id="minterms">Minterms<a hidden class="anchor" aria-hidden="true" href="#minterms">#</a></h3>
<ul>
<li>Minterm is a product term in which all variable appear exactly once (either complemented or uncomplemented)
<ul>
<li><img loading="lazy" src="/images/Fundie/MinTerms.png" alt="Minterms"  />
</li>
</ul>
</li>
<li>You can refer to each minterm by the unsigned int that they represent (mX)</li>
<li>A function can be described as a sum of its minterms
<ul>
<li>You can evauluate when the function is true by looking at the minterms</li>
</ul>
</li>
<li>You can marginalize on a literal by including the minterms that include literal and its complement</li>
<li>Minterm expansion is not a simplified form</li>
</ul>
<h3 id="maxterms">Maxterms<a hidden class="anchor" aria-hidden="true" href="#maxterms">#</a></h3>
<ul>
<li>The dual of minterms (ie a sum in which all variables appear exactly once, either complemented or uncomplemented)</li>
<li>Denoted as MX</li>
<li>The product expansion of a function in terms of maxterms
<ul>
<li>Whenever the function evaluates to zero, these inputs correspond to a particular maxterm in the expansion</li>
</ul>
</li>
</ul>
<h3 id="karnaugh-map">Karnaugh Map<a hidden class="anchor" aria-hidden="true" href="#karnaugh-map">#</a></h3>
<ul>
<li>Say that you have $F = X+\bar{X}Y$. How do you simplify this?
<ul>
<li>Replace $X = X+XY$ and turn the crank to get $F=X+Y$</li>
<li>Not immediately obvious. Need an automatic tool to help</li>
<li>Not the simplest form, but good enough</li>
</ul>
</li>
<li><img loading="lazy" src="/images/Fundie/2VarKMap.png" alt="2VarKMap"  />
</li>
<li>Expand the truth table into a 2D grid indexed Y horizontally and X vertically (origin from the top-left and moves right and down)
<ul>
<li>Each value of the input literal tells you where on the Karnaugh Map</li>
</ul>
</li>
<li><img loading="lazy" src="/images/Fundie/3VarKMap.png" alt="3VarKMap"  />

<ul>
<li>Let the vertical axis be X, and the horizontal be YZ
<ul>
<li>Gray encoding: order values of YZ such that only one bit changes at a time</li>
<li>Y goes on top, Z goes on bottom</li>
</ul>
</li>
</ul>
</li>
<li>Minterm product terms correspond to a $2^{i} \times 2^{j}$ rectangle (including wraparounds)
<ul>
<li>To find the simplest form you can derive from the k-map, you draw the largest rectangles you can (incluing wraparounds) and then relate these rectangles to products</li>
<li><img loading="lazy" src="/images/Fundie/WarpingKMap.png" alt="WarpKMap"  />
</li>
</ul>
</li>
</ul>
<h4 id="k-map-notation">K-map Notation<a hidden class="anchor" aria-hidden="true" href="#k-map-notation">#</a></h4>
<ul>
<li>Implicant: a product term comprised of minterms for which the function F evaluates to 1 (ie. a box whose dimensions are powers of 2)</li>
<li>Prime Implicant: there exists no other implicant that can contain this implicant</li>
<li>Essential Prime Implicant: this implicant covers at least one minterm that is not covered  by any other prime implicant</li>
<li><img loading="lazy" src="/images/Fundie/PrimeAndEssentialPrimeImplicants.png" alt="PrimeImpliants"  />
</li>
</ul>
<h4 id="summary-of-simplification-with-k-maps">Summary of Simplification with k-maps<a hidden class="anchor" aria-hidden="true" href="#summary-of-simplification-with-k-maps">#</a></h4>
<ul>
<li>Identify all the prime and essential prime implicants
<ul>
<li>Include all the essential PIs</li>
<li>If any 1-valued minterms are uncovered by EPIs, choose PIs that are &ldquo;big&rdquo; and do a good job covering
<ul>
<li>Heuristic: Choose the PIs that minimize overlap with one another and with EPIs</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-bit-multiplier">2-bit multiplier<a hidden class="anchor" aria-hidden="true" href="#2-bit-multiplier">#</a></h4>
<p><img loading="lazy" src="/images/Fundie/2BitMultiplierSimplified.png" alt="2BitMultiplier"  />
</p>
<ul>
<li>You have 2 2 bit numbers. You need 4 bits to represent the largest product</li>
<li>Each bit in the output can be written as a k-map, which can be simplified to write what inputs correspond to this particular output bit getting turned on</li>
</ul>
<h4 id="dont-care-conditions">Don&rsquo;t Care Conditions<a hidden class="anchor" aria-hidden="true" href="#dont-care-conditions">#</a></h4>
<ul>
<li>These are circumstances where the output doesn&rsquo;t matter
<ul>
<li>Going to the 2-bit multiplier, say that you know that some set of inputs will never occur. Hence you can ignore the output of those inputs when building a circuit</li>
</ul>
</li>
<li>Denote X as the outputs where you don&rsquo;t care about the output</li>
<li>In the k-map, replace the don&rsquo;t care conditions with X. You can optionally cover X&rsquo;s with EPI&rsquo;s (ie. you can include X&rsquo;s in larger boxes to simplify circuitry)</li>
</ul>
<h3 id="drawing-circuits">Drawing Circuits<a hidden class="anchor" aria-hidden="true" href="#drawing-circuits">#</a></h3>
<ul>
<li>Denote a circuit as a blob so you don&rsquo;t have to redraw a circuit over and over again</li>
<li>When an input changes, it takes time for the output to get updated</li>
</ul>
<h2 id="lecture-4">Lecture 4<a hidden class="anchor" aria-hidden="true" href="#lecture-4">#</a></h2>
<h3 id="standard-circuits">Standard Circuits<a hidden class="anchor" aria-hidden="true" href="#standard-circuits">#</a></h3>
<ul>
<li>NB: Think about circuits as having constant input</li>
</ul>
<h4 id="enabler">Enabler<a hidden class="anchor" aria-hidden="true" href="#enabler">#</a></h4>
<ul>
<li>Takes in data D (k bits in parallel), as well as an enable/disable trigger E. There is a single output of k bits
<ul>
<li>If E=1, the output equals the input</li>
<li>If E=0, output equals k 0&rsquo;s
<img loading="lazy" src="/images/Fundie/EnableHighLevel.png" alt="EnablerHighLevel"  />
</li>
</ul>
</li>
<li>Implement enabler with k AND gates. Each input has it&rsquo;s own AND gate, and the other pin is the Enable input
<img loading="lazy" src="/images/Fundie/EnablerLowLevel.png" alt="EnablerLowLevel"  />
</li>
</ul>
<h4 id="decoder-circuit">Decoder Circuit<a hidden class="anchor" aria-hidden="true" href="#decoder-circuit">#</a></h4>
<ul>
<li>Takes in a k-bit input and $2^{k}$ 1-bit outputs</li>
<li>The selector indicates as an unsigned binary which output = 1. All other outputs are zero
<img loading="lazy" src="/images/Fundie/DecoderHighLevel.png" alt="DecoderCircuitHighLevel"  />

<img loading="lazy" src="/images/Fundie/DecoderLowLevel.png" alt="DecoderCircuitLowLevel"  />
</li>
<li>Write truth table out. Each row is a minterm. Recall that each minterm evaluates for 1 for a unique combination of literals.</li>
<li>You can write decoders with a combination of NOTs and ANDs</li>
</ul>
<h4 id="decoder-with-enable">Decoder With Enable<a hidden class="anchor" aria-hidden="true" href="#decoder-with-enable">#</a></h4>
<ul>
<li>Slap the two previous circuits together</li>
<li>Push the output of the decoder through k AND gates where every AND gate has a input connected to the enable pin
<img loading="lazy" src="/images/Fundie/DecoderWEnableLowLevel.png" alt="DecoderCircuitLowLevel"  />
</li>
</ul>
<h4 id="mux-multiplexer">MUX (Multiplexer)<a hidden class="anchor" aria-hidden="true" href="#mux-multiplexer">#</a></h4>
<ul>
<li>Takes $2^{k}$ 1-bit data values as input. Has a k-bit selector that indicates in unsigned binary which data bit is output</li>
<li>You push all the data values in as input simultaneously, and only the one you select is the output. All other inputs are dropped
<img loading="lazy" src="/images/Fundie/MUXHighLevel.png" alt="MUXHigh"  />

<img loading="lazy" src="/images/Fundie/MUXLowLevel.png" alt="MUXLowLevel"  />

<ul>
<li>You have a selector part that chooses which input to select</li>
<li>You pass all this data to an enabler, whose output gets passed to an OR gate</li>
</ul>
</li>
</ul>
<h5 id="representing-functions-with-decoders-and-muxes">Representing Functions with Decoders and MUXes<a hidden class="anchor" aria-hidden="true" href="#representing-functions-with-decoders-and-muxes">#</a></h5>
<ul>
<li>Use a Decoder and OR together the minterms that evaluate to 1 of your function</li>
<li>Use a Multiplexer where you feed in the output of your function. The input to the multiplexer is the values that your literals you take. The output is then your function</li>
</ul>
<h5 id="mux-trick">MUX trick<a hidden class="anchor" aria-hidden="true" href="#mux-trick">#</a></h5>
<ul>
<li>Look at your truth table in pairs of rows. You can select on A and B as the selector input. You pass the C input as one of the the $2^{k}$ 1-bit inputs and it&rsquo;s complement</li>
</ul>
<h4 id="shifter-circuit">Shifter Circuit<a hidden class="anchor" aria-hidden="true" href="#shifter-circuit">#</a></h4>
<ul>
<li>k-bit data value enter as input</li>
<li>l-bit selector in unsigned binary tells how many bits to shift</li>
<li>k-bit output where bits are shifted by l-bits (can wraparound or drop out)
<img loading="lazy" src="/images/Fundie/ShifterHighLevel.png" alt="ShifterHIgh"  />
</li>
</ul>
<h5 id="barrel-shift-left-w-wraparound">Barrel Shift left w/ Wraparound<a hidden class="anchor" aria-hidden="true" href="#barrel-shift-left-w-wraparound">#</a></h5>
<ul>
<li>Say you want to shift over by 2 with wrap around</li>
<li>You use MUXes. Each output bit of the MUX goes to the output of the Shifter. All the MUXes have the same shift bit as their selector
<img loading="lazy" src="/images/Fundie/BarrelShifterWrapAround.png" alt="BarrelWraparound"  />
</li>
</ul>
<h5 id="l-r-shift-circuit-with-rollout">L-R Shift Circuit with Rollout<a hidden class="anchor" aria-hidden="true" href="#l-r-shift-circuit-with-rollout">#</a></h5>
<p><img loading="lazy" src="/images/Fundie/SelectorBitTable.png" alt="SelectorBitTable"  />

<img loading="lazy" src="/images/Fundie/LRShiftExample.png" alt="LRShifterEx"  />
</p>
<h4 id="unsigned-adder-circuit">Unsigned Adder Circuit<a hidden class="anchor" aria-hidden="true" href="#unsigned-adder-circuit">#</a></h4>
<ul>
<li>Two k-bit data values (A,B) and 1 bit carry in bit $C_{in}$</li>
<li>output is k-bit of $A+B+C_{in}$ and a carry out bit $_{out}$
<img loading="lazy" src="/images/Fundie/UnsignedAdderCircuit.png" alt="UnsignedAdderHigh"  />
</li>
</ul>
<h5 id="half-adder">Half-Adder<a hidden class="anchor" aria-hidden="true" href="#half-adder">#</a></h5>
<p><img loading="lazy" src="/images/Fundie/HalfAdder.png" alt="HalfAdder"  />
</p>
<ul>
<li>Takes two inputs A and B and returns a Sum and a carry
<ul>
<li>The sum is computed via XOR and the carry is computed by AND</li>
</ul>
</li>
</ul>
<h5 id="full-adder">Full-Adder<a hidden class="anchor" aria-hidden="true" href="#full-adder">#</a></h5>
<p><img loading="lazy" src="/images/Fundie/FullAdder.png" alt="FullAdder"  />
</p>
<ul>
<li>Takes as input 2 digits (A&amp;B) and previous carry (P)</li>
<li>Can daisy chain full adders together
<ul>
<li>Each subsequent adder needs to wait until the previous adder to finish</li>
</ul>
</li>
</ul>
<h4 id="signed-addersubtractor-2s-c">Signed Adder/Subtractor (2&rsquo;s-C)<a hidden class="anchor" aria-hidden="true" href="#signed-addersubtractor-2s-c">#</a></h4>
<h5 id="ripple-carry-adder">Ripple Carry Adder<a hidden class="anchor" aria-hidden="true" href="#ripple-carry-adder">#</a></h5>
<ul>
<li>Two k-bit data values and 1 bit S (0 for add, 1 for subtract)</li>
<li>Output is k-bit $A+B$ when S is 0 and $A-B$ when S is 1
<ul>
<li>You also have an overflow bit
<img loading="lazy" src="/images/Fundie/RippleCarryAdder.png" alt="RippleCarryAdder"  />
</li>
</ul>
</li>
<li>To calculate A-B, first flip B by XORing with 1 prior to sending the output of the XORs to a full adder with an initial carry of 1</li>
<li>Overflow can be calculated by XORing the highest order bits of the adder</li>
</ul>
<h5 id="optimizing-ripple-carry-carry-lookahead">Optimizing Ripple Carry (Carry Lookahead)<a hidden class="anchor" aria-hidden="true" href="#optimizing-ripple-carry-carry-lookahead">#</a></h5>
<ul>
<li>We try to parallelize the carry operations</li>
<li>When do we get carries</li>
<li>If the ith bit of A and B are the same (11 or 00), then you are guaranteed to either have a carry or not have a carry respectively</li>
<li>if the bits are different, what happens?
<ul>
<li>There is a carry iff the previous column has a carry</li>
<li>$C_{i+1} = A_{i}B_{i}+(A_{i}\otimes B_{i})A_{i-1}B_{i-1}$</li>
<li>This can be recursively expanded to the lowest order bit</li>
</ul>
</li>
</ul>
<h4 id="merge-with-known-0s">Merge with known 0&rsquo;s<a hidden class="anchor" aria-hidden="true" href="#merge-with-known-0s">#</a></h4>
<ul>
<li>Suppose we have m input signals</li>
<li>We know all of them except one is zero. The remaining bit could be zero or one. You also don&rsquo;t know which one is the unknown bit</li>
<li>Implement with an OR gate
<img loading="lazy" src="/images/Fundie/MergeWithKnown0.png" alt="MergeWithKnown0"  />
</li>
</ul>
<h4 id="code-converter">Code Converter<a hidden class="anchor" aria-hidden="true" href="#code-converter">#</a></h4>
<p><img loading="lazy" src="/images/Fundie/CodeConverterScoreboard.png" alt="CodeConverter"  />
</p>
<ul>
<li>Say that you want to build a circuit to light up a LED number. Denote each segment of the LED with a letter</li>
<li>Take in as input 4 variables WXYZ and output which segments to light up</li>
<li>Look at each column of the truth table, build a k-map from the column and then build a circuit</li>
</ul>
<h4 id="contraction">Contraction<a hidden class="anchor" aria-hidden="true" href="#contraction">#</a></h4>
<ul>
<li>Say that you have a circuit. Now you know that some inputs are fixed. YOu can simplify the circuit</li>
</ul>
<h5 id="example-1">Example 1<a hidden class="anchor" aria-hidden="true" href="#example-1">#</a></h5>
<ul>
<li>For an incrementor (add one to current value), you can replace full adder with half adders and be careful with the lowest order bit
<img loading="lazy" src="/images/Fundie/ContractionAdders.png" alt="ContractorFullAdder"  />
</li>
</ul>
<h2 id="lecture-5">Lecture 5<a hidden class="anchor" aria-hidden="true" href="#lecture-5">#</a></h2>
<h3 id="latch-intuition">Latch Intuition<a hidden class="anchor" aria-hidden="true" href="#latch-intuition">#</a></h3>
<ul>
<li>You a data bit X(t), a write bit W(t) and outputs of Q and complement of Q
<ul>
<li>If w is 1, then the Q follows X</li>
<li>If w equals 0, then Q maintains its current output, regardless of the input
<img loading="lazy" src="/images/Fundie/InuitiveLatch.png" alt="IntuitiveLatch"  />
</li>
</ul>
</li>
</ul>
<h3 id="sr-latch">SR Latch<a hidden class="anchor" aria-hidden="true" href="#sr-latch">#</a></h3>
<ul>
<li>We have a reset pin (R), a set pin (S), and output and inverted outputs (Q and $\bar{Q}$)
<img loading="lazy" src="/images/Fundie/RSCombinations.png" alt="RSCombinations"  />

<img loading="lazy" src="/images/Fundie/RSLatch.png" alt="RSLatch"  />

<ul>
<li>implemented with NOR gates
<img loading="lazy" src="/images/Fundie/ExcitationTable.png" alt="ExcitationTableRSLatch"  />
</li>
</ul>
</li>
<li>R = 1 and S =1 produces garbage</li>
<li>You can also construct a $\bar{S}\bar{R}$ Latch with NAND gates, where S=0 and R=0 is garbage instead</li>
</ul>
<h3 id="sr-latch-with-control">SR Latch with Control<a hidden class="anchor" aria-hidden="true" href="#sr-latch-with-control">#</a></h3>
<p><img loading="lazy" src="/images/Fundie/SRLatchWControl.png" alt="SRLatchWithControl"  />

<img loading="lazy" src="/images/Fundie/SRLatchControlExcitation.png" alt="SRLatchWithControlExciationTable"  />
</p>
<ul>
<li>We have S,R, and C being fed into NAND Gates, whose outputs get feed into $\bar{S}\bar{R}$ latch.</li>
<li>C controls wheather the latch is enabled or not. If the latch is not enabled, it defaults to holding its current value</li>
</ul>
<h3 id="d-latch-with-control">D Latch with control<a hidden class="anchor" aria-hidden="true" href="#d-latch-with-control">#</a></h3>
<ul>
<li>You have D and C being feed int NAND gates, where you invert one of the C inputs. The results are feed into an $\bar{S}\bar{R}$ latch. Implementation of intuitive idea of latch</li>
</ul>
<h3 id="heading"><a hidden class="anchor" aria-hidden="true" href="#heading">#</a></h3>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://mushetty.me">mushetty.me</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
